diff --git a/README.txt b/README.txt
index 6cab3ba..53ccce2 100644
--- a/README.txt
+++ b/README.txt
@@ -79,7 +79,6 @@ SYScall_Exit
 Check if it's parent is waiting for it
 If so then Set interrupts off and start runing paretn using ThreadIsReadyToRun() function
 set interrupts back on
-Make sure to set its childStatus with its exit status so that its parent knows it exited
 Then Destroy the thread using Finish() function
 
 
diff --git a/nachos/code/threads/thread.cc b/nachos/code/threads/thread.cc
index 240af9b..4ab0e1d 100755
--- a/nachos/code/threads/thread.cc
+++ b/nachos/code/threads/thread.cc
@@ -40,11 +40,12 @@ NachOSThread::NachOSThread(char* threadName)
     stackTop = NULL;
     stack = NULL;
     status = JUST_CREATED;
-    startPC=int(machine->ReadRegister(PCReg));//note the starting PC when thread is created so we can count number of instructions executed
+    startPC=int(machine->ReadRegister(PCReg));
      TotalProcesses++;
     pid=TotalProcesses;
 	childPidArray= new int[MaxThreads];
 	childStatusArray= new int[MaxThreads];
+    currentThread->childpidList->append(void *(&pid));
     if(pid==1)
     {
     	ppid=0;
diff --git a/nachos/code/threads/thread.cc~ b/nachos/code/threads/thread.cc~
deleted file mode 100755
index 21645a9..0000000
--- a/nachos/code/threads/thread.cc~
+++ /dev/null
@@ -1,370 +0,0 @@
-// thread.cc 
-//	Routines to manage threads.  There are four main operations:
-//
-//	ThreadFork -- create a thread to run a procedure concurrently
-//		with the caller (this is done in two steps -- first
-//		allocate the Thread object, then call ThredFork on it)
-//	Finish -- called when the forked procedure finishes, to clean up
-//	YieldCPU -- relinquish control over the CPU to another ready thread
-//	PutThreadToSleep -- relinquish control over the CPU, but thread is now blocked.
-//		In other words, it will not run again, until explicitly 
-//		put back on the ready queue.
-//
-// Copyright (c) 1992-1993 The Regents of the University of California.
-// All rights reserved.  See copyright.h for copyright notice and limitation 
-// of liability and disclaimer of warranty provisions.
-
-#include "copyright.h"
-#include "thread.h"
-#include "switch.h"
-#include "synch.h"
-#include "system.h"
-
-#define STACK_FENCEPOST 0xdeadbeef	// this is put at the top of the
-					// execution stack, for detecting 
-					// stack overflows
-int TotalProcesses=0;
-					
-
-//----------------------------------------------------------------------
-// NachOSThread::NachOSThread
-// 	Initialize a thread control block, so that we can then call
-//	NachOSThread::ThreadFork.
-//
-//	"threadName" is an arbitrary string, useful for debugging.
-//----------------------------------------------------------------------
-
-NachOSThread::NachOSThread(char* threadName)
-{
-    name = threadName;
-    stackTop = NULL;
-    stack = NULL;
-    status = JUST_CREATED;
-    startPC=int(machine->ReadRegister(PCReg));
-     TotalProcesses++;
-    pid=TotalProcesses;
-	childPidArray= new int[MaxThreads];
-	childStatusArray= new int[MaxThreads];
-    if(pid==1)
-    {
-    	ppid=0;
-    }
-    else
-    {
-    	ppid=currentThread->pid;
-    }
-   parent=currentThread;
-#ifdef USER_PROGRAM
-    space = NULL;
-#endif
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::~NachOSThread
-// 	De-allocate a thread.
-//
-// 	NOTE: the current thread *cannot* delete itself directly,
-//	since it is still running on the stack that we need to delete.
-//
-//      NOTE: if this is the main thread, we can't delete the stack
-//      because we didn't allocate it -- we got it automatically
-//      as part of starting up Nachos.
-//----------------------------------------------------------------------
-
-NachOSThread::~NachOSThread()
-{
-    DEBUG('t', "Deleting thread \"%s\"\n", name);
-
-    ASSERT(this != currentThread);
-    if (stack != NULL)
-	DeallocBoundedArray((char *) stack, StackSize * sizeof(int));
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::ThreadFork
-// 	Invoke (*func)(arg), allowing caller and callee to execute 
-//	concurrently.
-//
-//	NOTE: although our definition allows only a single integer argument
-//	to be passed to the procedure, it is possible to pass multiple
-//	arguments by making them fields of a structure, and passing a pointer
-//	to the structure as "arg".
-//
-// 	Implemented as the following steps:
-//		1. Allocate a stack
-//		2. Initialize the stack so that a call to SWITCH will
-//		cause it to run the procedure
-//		3. Put the thread on the ready queue
-// 	
-//	"func" is the procedure to run concurrently.
-//	"arg" is a single argument to be passed to the procedure.
-//----------------------------------------------------------------------
-
-void 
-NachOSThread::ThreadFork(VoidFunctionPtr func, int arg)
-{
-    DEBUG('t', "Forking thread \"%s\" with func = 0x%x, arg = %d\n",
-	  name, (int) func, arg);
-    
-    AllocateThreadStack(func, arg);
-
-    IntStatus oldLevel = interrupt->SetLevel(IntOff);
-    scheduler->ThreadIsReadyToRun(this);	// ThreadIsReadyToRun assumes that interrupts 
-					// are disabled!
-    (void) interrupt->SetLevel(oldLevel);
-}    
-
-//----------------------------------------------------------------------
-// NachOSThread::CheckOverflow
-// 	Check a thread's stack to see if it has overrun the space
-//	that has been allocated for it.  If we had a smarter compiler,
-//	we wouldn't need to worry about this, but we don't.
-//
-// 	NOTE: Nachos will not catch all stack overflow conditions.
-//	In other words, your program may still crash because of an overflow.
-//
-// 	If you get bizarre results (such as seg faults where there is no code)
-// 	then you *may* need to increase the stack size.  You can avoid stack
-// 	overflows by not putting large data structures on the stack.
-// 	Don't do this: void foo() { int bigArray[10000]; ... }
-//----------------------------------------------------------------------
-
-void
-NachOSThread::CheckOverflow()
-{
-    if (stack != NULL)
-#ifdef HOST_SNAKE			// Stacks grow upward on the Snakes
-	ASSERT(stack[StackSize - 1] == STACK_FENCEPOST);
-#else
-	ASSERT(*stack == STACK_FENCEPOST);
-#endif
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::FinishThread
-// 	Called by ThreadRoot when a thread is done executing the 
-//	forked procedure.
-//
-// 	NOTE: we don't immediately de-allocate the thread data structure 
-//	or the execution stack, because we're still running in the thread 
-//	and we're still on the stack!  Instead, we set "threadToBeDestroyed", 
-//	so that NachOSscheduler::Schedule() will call the destructor, once we're
-//	running in the context of a different thread.
-//
-// 	NOTE: we disable interrupts, so that we don't get a time slice 
-//	between setting threadToBeDestroyed, and going to sleep.
-//----------------------------------------------------------------------
-
-//
-int
-NachOSThread::getChildIndex(int childPid)
-{ 	
-	int i=0;
-	for(i=0;i<numChild;i++)
-	{
-		if(childPidArray[i]==childPid)
-		{
-		return i; 	
-		}
-	}
-	return -1;//-1 for there is no child
-}
-int
-NachOSThread::getChildStatus(int childPid)
-{
-	int index=getChildIndex(childPid);
-	return childStatusArray[index];
-}
-void
-NachOSThread::setChildStatus(int childPid,int st)
-{
-	int index=getChildIndex(childPid);
-	childStatusArray[index]=st;
-	return;
-}
-void
-NachOSThread::addChildToParent(int childPid,int st)
-{
-	numChild++;
-	childpidArray[numChild]=pid
-	childStatusArray[numChild]=st;
-	return;
-}
-void
-NachOSThread::FinishThread ()
-{
-    (void) interrupt->SetLevel(IntOff);		
-    ASSERT(this == currentThread);
-    
-    DEBUG('t', "Finishing thread \"%s\"\n", getName());
-    
-    threadToBeDestroyed = currentThread;
-    PutThreadToSleep();					// invokes SWITCH
-    // not reached
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::YieldCPU
-// 	Relinquish the CPU if any other thread is ready to run.
-//	If so, put the thread on the end of the ready list, so that
-//	it will eventually be re-scheduled.
-//
-//	NOTE: returns immediately if no other thread on the ready queue.
-//	Otherwise returns when the thread eventually works its way
-//	to the front of the ready list and gets re-scheduled.
-//
-//	NOTE: we disable interrupts, so that looking at the thread
-//	on the front of the ready list, and switching to it, can be done
-//	atomically.  On return, we re-set the interrupt level to its
-//	original state, in case we are called with interrupts disabled. 
-//
-// 	Similar to NachOSThread::PutThreadToSleep(), but a little different.
-//----------------------------------------------------------------------
-
-void
-NachOSThread::YieldCPU ()
-{
-    NachOSThread *nextThread;
-    IntStatus oldLevel = interrupt->SetLevel(IntOff);
-    
-    ASSERT(this == currentThread);
-    
-    DEBUG('t', "Yielding thread \"%s\"\n", getName());
-    
-    nextThread = scheduler->FindNextThreadToRun();
-    if (nextThread != NULL) {
-	scheduler->ThreadIsReadyToRun(this);
-	scheduler->Schedule(nextThread);
-    }
-    (void) interrupt->SetLevel(oldLevel);
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::PutThreadToSleep
-// 	Relinquish the CPU, because the current thread is blocked
-//	waiting on a synchronization variable (Semaphore, Lock, or Condition).
-//	Eventually, some thread will wake this thread up, and put it
-//	back on the ready queue, so that it can be re-scheduled.
-//
-//	NOTE: if there are no threads on the ready queue, that means
-//	we have no thread to run.  "Interrupt::Idle" is called
-//	to signify that we should idle the CPU until the next I/O interrupt
-//	occurs (the only thing that could cause a thread to become
-//	ready to run).
-//
-//	NOTE: we assume interrupts are already disabled, because it
-//	is called from the synchronization routines which must
-//	disable interrupts for atomicity.   We need interrupts off 
-//	so that there can't be a time slice between pulling the first thread
-//	off the ready list, and switching to it.
-//----------------------------------------------------------------------
-void
-NachOSThread::PutThreadToSleep ()
-{
-    NachOSThread *nextThread;
-    
-    ASSERT(this == currentThread);
-    ASSERT(interrupt->getLevel() == IntOff);
-    
-    DEBUG('t', "Sleeping thread \"%s\"\n", getName());
-
-    status = BLOCKED;
-    while ((nextThread = scheduler->FindNextThreadToRun()) == NULL)
-	interrupt->Idle();	// no one to run, wait for an interrupt
-        
-    scheduler->Schedule(nextThread); // returns when we've been signalled
-}
-
-//----------------------------------------------------------------------
-// ThreadFinish, InterruptEnable, ThreadPrint
-//	Dummy functions because C++ does not allow a pointer to a member
-//	function.  So in order to do this, we create a dummy C function
-//	(which we can pass a pointer to), that then simply calls the 
-//	member function.
-//----------------------------------------------------------------------
-
-static void ThreadFinish()    { currentThread->FinishThread(); }
-static void InterruptEnable() { interrupt->Enable(); }
-void ThreadPrint(int arg){ NachOSThread *t = (NachOSThread *)arg; t->Print(); }
-
-//----------------------------------------------------------------------
-// NachOSThread::AllocateThreadStack
-//	Allocate and initialize an execution stack.  The stack is
-//	initialized with an initial stack frame for ThreadRoot, which:
-//		enables interrupts
-//		calls (*func)(arg)
-//		calls NachOSThread::FinishThread
-//
-//	"func" is the procedure to be forked
-//	"arg" is the parameter to be passed to the procedure
-//----------------------------------------------------------------------
-
-void
-NachOSThread::AllocateThreadStack (VoidFunctionPtr func, int arg)
-{
-    stack = (int *) AllocBoundedArray(StackSize * sizeof(int));
-
-#ifdef HOST_SNAKE
-    // HP stack works from low addresses to high addresses
-    stackTop = stack + 16;	// HP requires 64-byte frame marker
-    stack[StackSize - 1] = STACK_FENCEPOST;
-#else
-    // i386 & MIPS & SPARC stack works from high addresses to low addresses
-#ifdef HOST_SPARC
-    // SPARC stack must contains at least 1 activation record to start with.
-    stackTop = stack + StackSize - 96;
-#else  // HOST_MIPS  || HOST_i386
-    stackTop = stack + StackSize - 4;	// -4 to be on the safe side!
-#ifdef HOST_i386
-    // the 80386 passes the return address on the stack.  In order for
-    // SWITCH() to go to ThreadRoot when we switch to this thread, the
-    // return addres used in SWITCH() must be the starting address of
-    // ThreadRoot.
-    *(--stackTop) = (int)_ThreadRoot;
-#endif
-#endif  // HOST_SPARC
-    *stack = STACK_FENCEPOST;
-#endif  // HOST_SNAKE
-    
-    machineState[PCState] = (int) _ThreadRoot;
-    machineState[StartupPCState] = (int) InterruptEnable;
-    machineState[InitialPCState] = (int) func;
-    machineState[InitialArgState] = arg;
-    machineState[WhenDonePCState] = (int) ThreadFinish;
-}
-
-#ifdef USER_PROGRAM
-#include "machine.h"
-
-//----------------------------------------------------------------------
-// NachOSThread::SaveUserState
-//	Save the CPU state of a user program on a context switch.
-//
-//	Note that a user program thread has *two* sets of CPU registers -- 
-//	one for its state while executing user code, one for its state 
-//	while executing kernel code.  This routine saves the former.
-//----------------------------------------------------------------------
-
-void
-NachOSThread::SaveUserState()
-{
-    for (int i = 0; i < NumTotalRegs; i++)
-	userRegisters[i] = machine->ReadRegister(i);
-}
-
-//----------------------------------------------------------------------
-// NachOSThread::RestoreUserState
-//	Restore the CPU state of a user program on a context switch.
-//
-//	Note that a user program thread has *two* sets of CPU registers -- 
-//	one for its state while executing user code, one for its state 
-//	while executing kernel code.  This routine restores the former.
-//----------------------------------------------------------------------
-
-void
-NachOSThread::RestoreUserState()
-{
-    for (int i = 0; i < NumTotalRegs; i++)
-	machine->WriteRegister(i, userRegisters[i]);
-}
-#endif
diff --git a/nachos/code/threads/thread.h b/nachos/code/threads/thread.h
index fb7b6df..597e596 100755
--- a/nachos/code/threads/thread.h
+++ b/nachos/code/threads/thread.h
@@ -125,7 +125,7 @@ class NachOSThread {
     void SaveUserState();		// save user-level register state
     void RestoreUserState();		// restore user-level register state
     int pid, ppid;			// My pid and my parent's pid
-    int startPC;//TODO LOOKS correct as each register is of type int
+    int startPC;//TODO is this type correct
     NachOSThread * parent;
     int * childpidArray;
     int * childstatusArray;
diff --git a/nachos/code/threads/thread.h~ b/nachos/code/threads/thread.h~
deleted file mode 100755
index fb7b6df..0000000
--- a/nachos/code/threads/thread.h~
+++ /dev/null
@@ -1,155 +0,0 @@
-// thread.h 
-//	Data structures for managing threads.  A thread represents
-//	sequential execution of code within a program.
-//	So the state of a thread includes the program counter,
-//	the processor registers, and the execution stack.
-//	
-// 	Note that because we allocate a fixed size stack for each
-//	thread, it is possible to overflow the stack -- for instance,
-//	by recursing to too deep a level.  The most common reason
-//	for this occuring is allocating large data structures
-//	on the stack.  For instance, this will cause problems:
-//
-//		void foo() { int buf[1000]; ...}
-//
-//	Instead, you should allocate all data structures dynamically:
-//
-//		void foo() { int *buf = new int[1000]; ...}
-//
-//
-// 	Bad things happen if you overflow the stack, and in the worst 
-//	case, the problem may not be caught explicitly.  Instead,
-//	the only symptom may be bizarre segmentation faults.  (Of course,
-//	other problems can cause seg faults, so that isn't a sure sign
-//	that your thread stacks are too small.)
-//	
-//	One thing to try if you find yourself with seg faults is to
-//	increase the size of thread stack -- ThreadStackSize.
-//
-//  	In this interface, forking a thread takes two steps.
-//	We must first allocate a data structure for it: "t = new NachOSThread".
-//	Only then can we do the fork: "t->fork(f, arg)".
-//
-// Copyright (c) 1992-1993 The Regents of the University of California.
-// All rights reserved.  See copyright.h for copyright notice and limitation 
-// of liability and disclaimer of warranty provisions.
-
-#ifndef THREAD_H
-#define THREAD_H
-
-#include "copyright.h"
-#include "utility.h"
-#ifdef USER_PROGRAM
-#include "machine.h"
-#include "addrspace.h"
-#endif
-
-// CPU register state to be saved on context switch.  
-// The SPARC and MIPS only need 10 registers, but the Snake needs 18.
-// For simplicity, this is just the max over all architectures.
-#define MachineStateSize 18 
-
-
-// Size of the thread's private execution stack.
-// WATCH OUT IF THIS ISN'T BIG ENOUGH!!!!!
-#define StackSize	(4 * 1024)	// in words
-#define MaxThreads 1000
-#define Parent_Waiting 2
-#define Child_Running 1
-// Thread state
-enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };
-
-// external function, dummy routine whose sole job is to call NachOSThread::Print
-extern void ThreadPrint(int arg);	 
-
-// The following class defines a "thread control block" -- which
-// represents a single thread of execution.
-//
-//  Every thread has:
-//     an execution stack for activation records ("stackTop" and "stack")
-//     space to save CPU registers while not running ("machineState")
-//     a "status" (running/ready/blocked)
-//    
-//  Some threads also belong to a user address space; threads
-//  that only run in the kernel have a NULL address space.
-
-class NachOSThread {
-  private:
-    // NOTE: DO NOT CHANGE the order of these first two members.
-    // THEY MUST be in this position for SWITCH to work.
-    int* stackTop;			 // the current stack pointer
-    int machineState[MachineStateSize];  // all registers except for stackTop
-
-  public:
-    NachOSThread(char* debugName);		// initialize a Thread 
-    ~NachOSThread(); 				// deallocate a Thread
-					// NOTE -- thread being deleted
-					// must not be running when delete 
-					// is called
-
-    // basic thread operations
-
-    void ThreadFork(VoidFunctionPtr func, int arg); 	// Make thread run (*func)(arg)
-    void YieldCPU();  				// Relinquish the CPU if any 
-						// other thread is runnable
-    void PutThreadToSleep();  				// Put the thread to sleep and 
-						// relinquish the processor
-    void FinishThread();  				// The thread is done executing
-    
-    void CheckOverflow();   			// Check if thread has 
-						// overflowed its stack
-    void setStatus(ThreadStatus st) { status = st; }
-    char* getName() { return (name); }
-    void Print() { printf("%s, ", name); }
-
-  private:
-    // some of the private data for this class is listed above
-    
-    int* stack; 	 		// Bottom of the stack 
-					// NULL if this is the main thread
-					// (If NULL, don't deallocate stack)
-    ThreadStatus status;		// ready, running or blocked
-    char* name;
-
-    void AllocateThreadStack(VoidFunctionPtr func, int arg);
-    					// Allocate a stack for thread.
-					// Used internally by ThreadFork()
-#ifdef USER_PROGRAM
-// A thread running a user program actually has *two* sets of CPU registers -- 
-// one for its state while executing user code, one for its state 
-// while executing kernel code.
-
-    int userRegisters[NumTotalRegs];	// user-level CPU register state
-
-  public:
-    void SaveUserState();		// save user-level register state
-    void RestoreUserState();		// restore user-level register state
-    int pid, ppid;			// My pid and my parent's pid
-    int startPC;//TODO LOOKS correct as each register is of type int
-    NachOSThread * parent;
-    int * childpidArray;
-    int * childstatusArray;
-    int getChildIndex(int childPid);
-    int getChildStatus(int childPid);
-	int setChildStatus(int childPid,int st);
-	void addChildToParent(int childPid,int st);
-    int numChild=0;
-	int endofArray=0;
-    ProcessAddrSpace *space;			// User code this thread is running.
-#endif
-};
-
-// Magical machine-dependent routines, defined in switch.s
-
-extern "C" {
-// First frame on thread execution stack; 
-//   	enable interrupts
-//	call "func"
-//	(when func returns, if ever) call ThreadFinish()
-void _ThreadRoot();
-
-// Stop running oldThread and start running newThread
-void _SWITCH(NachOSThread *oldThread, NachOSThread *newThread);
-}
-
-#endif // THREAD_H
diff --git a/nachos/code/userprog/exception.cc b/nachos/code/userprog/exception.cc
index 6a55989..a3baa9a 100755
--- a/nachos/code/userprog/exception.cc
+++ b/nachos/code/userprog/exception.cc
@@ -252,31 +252,10 @@ ExceptionHandler(ExceptionType which)
         {
         	//TODO:
 			int status=currentThread->getChildStatus(childPID);
-			if(status==Child_Running)
-			{
-				currentThread->setChildStatus(childPID,Parent_Waiting);
-				interrupt->SetLevel(IntOff);
-        			currentThread->PutThreadToSleep();
-        			interrupt->SetLevel(IntOn);
-			}
-			else
-			{
-				returnValue=-1; //pid for child created but it already exited before
-			}	
-
-			//Now we need to make sure that when ever this thread wakes for some reason and and childStatus is still Parent_Waiting ie., child did not exit
-
-			status=currentThread->getChildStatus(childPID); //Could be exit status instead of Parent_Waiting
-
-			while(status==Parent_Waiting)
-			{
-				interrupt->SetLevel(IntOff);
-        			currentThread->PutThreadToSleep();
-        			interrupt->SetLevel(IntOn);
-				status=currentThread->getChildStatus(childPID);
-			}
-
-			
+			currentThread->setChildStatus(childPID,Parent_Waiting);
+			interrupt->SetLevel(IntOff);
+        	currentThread->PutThreadToSleep();
+        	interrupt->SetLevel(IntOn);	
         }
 
        machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
@@ -311,19 +290,19 @@ ExceptionHandler(ExceptionType which)
     }
 	else if ((which == SyscallException) && (type == SYScall_Fork)) {
 		
-	    	machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-            machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-            machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
+	    machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
+        machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
+        machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
        
-	    	NachOSThread * childThread = new NachosThread("child thread");//constructor of thread class
-			currentThread->AddChildToParent(childThread->pid,Child_Running);
+	    NachOSThread * childThread = new NachosThread("child thread");//constructor of thread class
+		currentThread->AddChildToParent(childThread->pid,Child_Running);
 
-		//TODO:add code to copy stack and address space to child
+		//TODO:add code to copy stack and address space
 
-			machine->WriteRegister(2,childThread->pid);
-			interrupt->SetLevel(IntOff);
-		    ThreadIsReadyToRun(childThread);
-		    interrupt->SetLevel(IntOn);	
+		machine->WriteRegister(2,childThread->pid);
+		interrupt->SetLevel(IntOff);
+        ThreadIsReadyToRun(childThread);
+        interrupt->SetLevel(IntOn);	
 		 
         }
 	else if ((which == SyscallException) && (type == SYScall_Exit)) {
@@ -340,7 +319,6 @@ ExceptionHandler(ExceptionType which)
         		interrupt->SetLevel(IntOn);	
 			}
 		}
-		currentThread->parent->setChildStatus(currentThread->pid,status) //set its exit status so parent knows it exited
 		currentThread->Finish();//detailed in draft
 		 
         }
diff --git a/nachos/code/userprog/exception.cc~ b/nachos/code/userprog/exception.cc~
deleted file mode 100755
index 31b44de..0000000
--- a/nachos/code/userprog/exception.cc~
+++ /dev/null
@@ -1,358 +0,0 @@
-// exception.cc 
-//	Entry point into the Nachos kernel from user programs.
-//	There are two kinds of things that can cause control to
-//	transfer back to here from user code:
-//
-//	syscall -- The user code explicitly requests to call a procedure
-//	in the Nachos kernel.  Right now, the only function we support is
-//	"Halt".
-//
-//	exceptions -- The user code does something that the CPU can't handle.
-//	For instance, accessing memory that doesn't exist, arithmetic errors,
-//	etc.  
-//
-//	Interrupts (which can also cause control to transfer from user
-//	code into the Nachos kernel) are handled elsewhere.
-//
-// For now, this only handles the Halt() system call.
-// Everything else core dumps.
-//
-// Copyright (c) 1992-1993 The Regents of the University of California.
-// All rights reserved.  See copyright.h for copyright notice and limitation 
-// of liability and disclaimer of warranty provisions.
-
-#include "copyright.h"
-#include "system.h"
-#include "syscall.h"
-#include "console.h"
-#include "synch.h"
-
-//----------------------------------------------------------------------
-// ExceptionHandler
-// 	Entry point into the Nachos kernel.  Called when a user program
-//	is executing, and either does a syscall, or generates an addressing
-//	or arithmetic exception.
-//
-// 	For system calls, the following is the calling convention:
-//
-// 	system call code -- r2
-//		arg1 -- r4
-//		arg2 -- r5
-//		arg3 -- r6
-//		arg4 -- r7
-//
-//	The result of the system call, if any, must be put back into r2. 
-//
-// And don't forget to increment the pc before returning. (Or else you'll
-// loop making the same system call forever!
-//
-//	"which" is the kind of exception.  The list of possible exceptions 
-//	are in machine.h.
-//----------------------------------------------------------------------
-static Semaphore *readAvail;
-static Semaphore *writeDone;
-static void ReadAvail(int arg) { readAvail->V(); }
-static void WriteDone(int arg) { writeDone->V(); }
-
-static void ConvertIntToHex (unsigned v, Console *console)
-{
-   unsigned x;
-   if (v == 0) return;
-   ConvertIntToHex (v/16, console);
-   x = v % 16;
-   if (x < 10) {
-      writeDone->P() ;
-      console->PutChar('0'+x);
-   }
-   else {
-      writeDone->P() ;
-      console->PutChar('a'+x-10);
-   }
-}
-
-void
-ExceptionHandler(ExceptionType which)
-{
-    int type = machine->ReadRegister(2);
-    int memval, vaddr, printval, tempval, exp;
-    unsigned printvalus;        // Used for printing in hex
-    if (!initializedConsoleSemaphores) {
-       readAvail = new Semaphore("read avail", 0);
-       writeDone = new Semaphore("write done", 1);
-       initializedConsoleSemaphores = true;
-    }
-    Console *console = new Console(NULL, NULL, ReadAvail, WriteDone, 0);;
-
-    if ((which == SyscallException) && (type == SYScall_Halt)) {
-	DEBUG('a', "Shutdown, initiated by user program.\n");
-   	interrupt->Halt();
-    }
-    else if ((which == SyscallException) && (type == SYScall_PrintInt)) {
-       printval = machine->ReadRegister(4);
-       if (printval == 0) {
-	  writeDone->P() ;
-          console->PutChar('0');
-       }
-       else {
-          if (printval < 0) {
-	     writeDone->P() ;
-             console->PutChar('-');
-             printval = -printval;
-          }
-          tempval = printval;
-          exp=1;
-          while (tempval != 0) {
-             tempval = tempval/10;
-             exp = exp*10;
-          }
-          exp = exp/10;
-          while (exp > 0) {
-	     writeDone->P() ;
-             console->PutChar('0'+(printval/exp));
-             printval = printval % exp;
-             exp = exp/10;
-          }
-       }
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-    else if ((which == SyscallException) && (type == SYScall_PrintChar)) {
-	writeDone->P() ;
-        console->PutChar(machine->ReadRegister(4));   // echo it!
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-    else if ((which == SyscallException) && (type == SYScall_PrintString)) {
-       vaddr = machine->ReadRegister(4);
-       machine->ReadMem(vaddr, 1, &memval);
-       while ((*(char*)&memval) != '\0') {
-	  writeDone->P() ;
-          console->PutChar(*(char*)&memval);
-          vaddr++;
-          machine->ReadMem(vaddr, 1, &memval);
-       }
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-    else if ((which == SyscallException) && (type == SYScall_PrintIntHex)) {
-       printvalus = (unsigned)machine->ReadRegister(4);
-       writeDone->P() ;
-       console->PutChar('0');
-       writeDone->P() ;
-       console->PutChar('x');
-       if (printvalus == 0) {
-          writeDone->P() ;
-          console->PutChar('0');
-       }
-       else {
-          ConvertIntToHex (printvalus, console);
-       }
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    } 
-	
-    else if ((which == SyscallException) && (type == SYScall_GetReg)) {
-        int reg_num=(machine->ReadRegister(4));
-	int curr_reg=(machine->ReadRegister(reg_num)); 
-	machine->WriteRegister(2,curr_reg); 
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-     else if ((which == SyscallException) && (type == SYScall_GetPA)) {
-        int virtual_address=(machine->ReadRegister(4));
-	int virt_page_num=(virtual_address)/(PageSize);
-	int return_value;
-	if((virt_page_num<=(machine->pageTableSize))&&(machine->NachOSpageTable[virt_page_num].valid==TRUE)&&(machine->NachOSpageTable[virt_page_num].physicalPage<=NumPhysPages))
-	{
-		//TODO: verify
-			Translate(virtual_address, &return_value, 4, false);
-		//virtual address to physical address should go here(def in translate method)
-	}
-	else
-	{
-		return_value=-1;
-	}
-	 machine->WriteRegister(2,return_value);
-        //int curr_reg=(int)(machine->ReadRegister(reg_num));
-        //machine->WriteRegister(2,curr_reg);
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-    else if ((which == SyscallException) && (type == SYScall_Time)) {
-    int curr_ticks=(stats->totalTicks); 
-	machine->WriteRegister(2,curr_reg); 
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-    else if ((which == SyscallException) && (type == SYScall_GetPID)) {
-    int curr_pid=(currentThread->pid); 
-	machine->WriteRegister(2,curr_pid); 
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-     else if ((which == SyscallException) && (type == SYScall_GetPPID)) {
-    int curr_ppid=(currentThread->ppid); 
-	machine->WriteRegister(2,curr_ppid); 
-       // Advance program counters.
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-    }
-     else if ((which == SyscallException) && (type == SYScall_Sleep)) {
-     	//Advance PC first as the curret process will go to sleep later and we will not be able advance PC
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-        int SleepTime=(machine->ReadRegister(4));
-        if(SleepTime==0)
-        {
-        	currentThread->YieldCPU();
-        }
-        else
-        {
-        	wakeUpTime=(SleepTime+(stats->totalTicks));
-        	sleepThreadList->SortedInsert((void *)currentThread,wakeUpTime);
-        	interrupt->SetLevel(IntOff);
-        	currentThread->PutThreadToSleep();
-        	interrupt->SetLevel(IntOn);
-        }
-      
-    }
-    else if ((which == SyscallException) && (type == SYScall_Yield)) {
-    	
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-       
-        currentThread->YieldCPU();
-    }
-    else if ((which == SyscallException) && (type == SYScall_Join)) {
-        int childPID=(machine->ReadRegister(4));
-        if(getChildIndex(childPID)==-1)
-        {
-        	returnValue=-1;
-        }
-        else
-        {
-        	//TODO:
-			int status=currentThread->getChildStatus(childPID);
-			if(status==Child_Running)
-			{
-				currentThread->setChildStatus(childPID,Parent_Waiting);
-				interrupt->SetLevel(IntOff);
-        			currentThread->PutThreadToSleep();
-        			interrupt->SetLevel(IntOn);
-			}
-			else
-			{
-				returnValue=-1; //pid for child created but it already exited before
-			}	
-
-			//Now we need to make sure that when ever this thread wakes for some reason and and childStatus is still Parent_Waiting ie., child did not exit
-
-			status=currentThread->getChildStatus(childPID); //Could be exit status instead of Parent_Waiting
-
-			while(status==Parent_Waiting)
-			{
-				interrupt->SetLevel(IntOff);
-        			currentThread->PutThreadToSleep();
-        			interrupt->SetLevel(IntOn);
-				status=currentThread->getChildStatus(childPID);
-			}
-
-			
-        }
-
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-        
-    }
-    else if ((which == SyscallException) && (type == SYScall_Exec)) {
-        int filename=(machine->ReadRegister(4));
-        //Code from start user process
-        //TODO should add code to change filename into char pointer so Open can work
-      OpenFile *executable = fileSystem->Open(filename);
-    ProcessAddrSpace *space;
-
-    if (executable == NULL) {
-	printf("Unable to open file %s\n", filename);
-	return;
-    }
-    space = new ProcessAddrSpace(executable);    
-    currentThread->space = space;
-
-    delete executable;			// close file
-
-    space->InitUserCPURegisters();		// set the initial register values
-    space->RestoreStateOnSwitch();		// load page table register
-
-    machine->Run();			// jump to the user progam
-    ASSERT(FALSE);			// machine->Run never returns;
-					// the address space exits
-					// by doing the syscall "exit"   
-               
-    }
-	else if ((which == SyscallException) && (type == SYScall_Fork)) {
-		
-	    machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-        machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-        machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-       
-	    NachOSThread * childThread = new NachosThread("child thread");//constructor of thread class
-		currentThread->AddChildToParent(childThread->pid,Child_Running);
-
-		//TODO:add code to copy stack and address space to child
-
-		machine->WriteRegister(2,childThread->pid);
-		interrupt->SetLevel(IntOff);
-        ThreadIsReadyToRun(childThread);
-        interrupt->SetLevel(IntOn);	
-		 
-        }
-	else if ((which == SyscallException) && (type == SYScall_Exit)) {
-		//TODO:
-		int status=(machine->ReadRegister(4));
-		if(currentThread->parent != NULL)
-		{
-			int threadStatusAsChild=(currentThread->parent->getChildStatus(currentThread->pid));
-
-			if(threadStatusAsChild==Parent_Waiting)
-			{
-				interrupt->SetLevel(IntOff);
-        		ThreadIsReadyToRun(currentThread->parent);
-        		interrupt->SetLevel(IntOn);	
-			}
-		}
-		currentThread->parent->setChildStatus(currentThread->pid,status) //set its exit status so parent knows it exited
-		currentThread->Finish();//detailed in draft
-		 
-        }
-     else if ((which == SyscallException) && (type == SYScall_NumInstr)) {
-       //TODO:
-       machine->WriteRegister(2,(machine->ReadRegister(PCReg)-currentThread->startPC)/4);//TODO check if each has its own PC
-       machine->WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
-       machine->WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
-       machine->WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg)+4);
-     }
-	else {
-	printf("Unexpected user mode exception %d %d\n", which, type);
-	ASSERT(FALSE);
-    }
-}
